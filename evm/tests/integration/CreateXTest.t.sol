// SPDX-License-Identifier: MIT
pragma solidity 0.8.29;

import {ICreateX} from "../../interfaces/ICreateX.sol";
import {Test, console} from "forge-std/Test.sol";

/*
 * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * @@@@@@@@@/         '@@@@/            /@@@/         '@@@@@@@@
 * @@@@@@@@/    /@@@    @@@@@@/    /@@@@@@@/    /@@@    @@@@@@@
 * @@@@@@@/           _@@@@@@/    /@@@@@@@/    /.     _@@@@@@@@
 * @@@@@@/    /@@@    '@@@@@/    /@@@@@@@/    /@@    @@@@@@@@@@
 * @@@@@/            ,@@@@@/    /@@@@@@@/    /@@@,    @@@@@@@@@
 * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 *
 * @title CreateX Test - Tests for CreateX factory usage
 * @copyright 2025
 * @notice Verifies deployments using the CreateX deterministic deployment proxy
 * @dev Ensures compatibility with CreateX patterns if used
 * @author BTR Team
 */

contract CreateXTest is Test {
    // From .env file
    address DEPLOYER = vm.envAddress("DEPLOYER");
    address CREATEX = vm.envAddress("CREATEX");
    // Add back the constants for verification
    address constant TEST_FACTORY = 0xba5Ed099633D3B313e4D5F7bdc1305d3c28ba5Ed; // Checksummed
    address constant TEST_DEPLOYER = 0x57b3771F6b772C52E81646Aa007D1Ab28d91B3Fe; // Already checksummed
    // Test contract bytecode
    bytes constant SIMPLE_CONTRACT_BYTECODE =
        hex"6080604052348015600f57600080fd5b50603f80601d6000396000f3fe6080604052600080fdfea2646970667358221220d4fa15a7fbd8dc8f6ba8a1be307b4f4c4b715f79e46fc2a25ab02d13a52dc84d64736f6c63430008160033";

    ICreateX createX;

    function setUp() public {
        // Fork BNB Chain for testing
        vm.createSelectFork("https://bsc-dataseed.bnbchain.org");

        // Connect to CreateX contract - Use TEST_FACTORY for verification tests
        // Ensure this uses the correct factory for the tests that need it
        createX = ICreateX(TEST_FACTORY);
    }

    function test_CreateXSalt() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        // A sample salt generated by our mining tool
        bytes32 salt = 0x0000000000000000000000000000000000000000000000000000000000000001;

        // Compute the expected address
        address expectedAddress = createX.computeCreate3Address(salt);
        console.log("Expected address for salt:", expectedAddress);

        // Deploy using Create3 and verify
        address deployedAddress = createX.deployCreate3(salt, SIMPLE_CONTRACT_BYTECODE);

        // Verify deployed address matches expected
        assertEq(deployedAddress, expectedAddress, "Deployed address should match computed address");
        console.log("Deployed address:", deployedAddress);

        // Stop pranking at the end
        vm.stopPrank();
    }

    function test_CreateXSaltVariant_Sender() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        // Salt with sender variant (first 20 bytes = sender, byte 21 = 0x00)
        bytes32 salt = bytes32(
            abi.encodePacked(
                DEPLOYER, // First 20 bytes: calling address
                hex"00", // Byte 21: no cross-chain protection
                hex"000001" // Remaining bytes: random salt part
            )
        );

        // Compute the expected address
        address expectedAddress = createX.computeCreate3Address(salt);
        console.log("Expected address for sender variant:", expectedAddress);

        // Deploy using Create3 and verify
        address deployedAddress = createX.deployCreate3(salt, SIMPLE_CONTRACT_BYTECODE);

        // Verify deployed address matches expected
        assertEq(deployedAddress, expectedAddress, "Deployed address should match computed address");
        console.log("Deployed address:", deployedAddress);

        // Stop pranking at the end
        vm.stopPrank();
    }

    function test_CreateXSaltVariant_Crosschain() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        // Salt with crosschain variant (first 20 bytes = address(0), byte 21 = 0x01)
        bytes32 salt = bytes32(
            abi.encodePacked(
                address(0), // First 20 bytes: zero address
                hex"01", // Byte 21: with cross-chain protection
                hex"000001" // Remaining bytes: random salt part
            )
        );

        // Compute the expected address
        address expectedAddress = createX.computeCreate3Address(salt);
        console.log("Expected address for crosschain variant:", expectedAddress);

        // Deploy using Create3 and verify
        address deployedAddress = createX.deployCreate3(salt, SIMPLE_CONTRACT_BYTECODE);

        // Verify deployed address matches expected
        assertEq(deployedAddress, expectedAddress, "Deployed address should match computed address");
        console.log("Deployed address:", deployedAddress);

        // Stop pranking at the end
        vm.stopPrank();
    }

    function test_CreateXSaltVariant_CrosschainSender() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        // Salt with crosschain sender variant (first 20 bytes = sender, byte 21 = 0x01)
        bytes32 salt = bytes32(
            abi.encodePacked(
                DEPLOYER, // First 20 bytes: calling address
                hex"01", // Byte 21: with cross-chain protection
                hex"000001" // Remaining bytes: random salt part
            )
        );

        // Compute the expected address
        address expectedAddress = createX.computeCreate3Address(salt);
        console.log("Expected address for crosschain sender variant:", expectedAddress);

        // Deploy using Create3 and verify
        address deployedAddress = createX.deployCreate3(salt, SIMPLE_CONTRACT_BYTECODE);

        // Verify deployed address matches expected
        assertEq(deployedAddress, expectedAddress, "Deployed address should match computed address");
        console.log("Deployed address:", deployedAddress);

        // Stop pranking at the end
        vm.stopPrank();
    }

    function test_OriginalNonces_Method1() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        console.log("Testing with original nonces - Method 1...");

        // The original nonces from output.txt and their corresponding expected addresses
        bytes8[] memory originalNonces = new bytes8[](4);
        originalNonces[0] = hex"000000000176ce3f"; // First salt
        originalNonces[1] = hex"000000000207e4bb"; // Second salt
        originalNonces[2] = hex"00000000021199e1"; // Third salt
        originalNonces[3] = hex"00000000033f7856"; // Fourth salt

        address[] memory expectedAddresses = new address[](4);
        expectedAddresses[0] = 0xbbbBDEF37e6ebEB7f6Eec464dEE9A33955919300;
        expectedAddresses[1] = 0xBbBb5fc751BDd39553036922706Cc9eD9F32b100;
        expectedAddresses[2] = 0xbbBB7dc22F1006364fD291C9522d276B9f1d5F00;
        expectedAddresses[3] = 0xBBbb6AB200Fa31AdCA4Df6aba3ccA1Ada1Ff4100;

        for (uint256 i = 0; i < originalNonces.length; i++) {
            bytes8 originalNonce = originalNonces[i];
            address expectedAddress = expectedAddresses[i];

            console.log("Salt", i, "original nonce:", vm.toString(originalNonce));
            console.log("  Expected address:", expectedAddress);

            // Method 1: Try forming the salt with the original nonce in entropy position
            bytes32 salt = bytes32(
                abi.encodePacked(
                    DEPLOYER, // First 20 bytes
                    hex"00", // 21st byte (no cross-chain protection)
                    originalNonce, // The original 8-byte nonce
                    bytes3(0x000000) // Padding to make 32 bytes
                )
            );

            // When CreateX processes this salt type (sender with 0x00 flag), it uses the _efficientHash function
            // _efficientHash(bytes32(uint256(uint160(msg.sender))), salt)
            bytes32 processedSalt = efficientHash(bytes32(uint256(uint160(DEPLOYER))), salt);
            address addr = createX.computeCreate3Address(processedSalt);
            console.log("  Processed sender salt:", addr, addr == expectedAddress ? " [MATCH]" : "");
        }
    }

    function test_OriginalNonces_Method2() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        console.log("Testing with original nonces - Method 2...");

        // The original nonces from output.txt and their corresponding expected addresses
        bytes8[] memory originalNonces = new bytes8[](4);
        originalNonces[0] = hex"000000000176ce3f"; // First salt
        originalNonces[1] = hex"000000000207e4bb"; // Second salt
        originalNonces[2] = hex"00000000021199e1"; // Third salt
        originalNonces[3] = hex"00000000033f7856"; // Fourth salt

        address[] memory expectedAddresses = new address[](4);
        expectedAddresses[0] = 0xbbbBDEF37e6ebEB7f6Eec464dEE9A33955919300;
        expectedAddresses[1] = 0xBbBb5fc751BDd39553036922706Cc9eD9F32b100;
        expectedAddresses[2] = 0xbbBB7dc22F1006364fD291C9522d276B9f1d5F00;
        expectedAddresses[3] = 0xBBbb6AB200Fa31AdCA4Df6aba3ccA1Ada1Ff4100;

        for (uint256 i = 0; i < originalNonces.length; i++) {
            bytes8 originalNonce = originalNonces[i];
            address expectedAddress = expectedAddresses[i];

            console.log("Salt", i, "original nonce:", vm.toString(originalNonce));

            // Method 2: Try with reversed nonce bytes (little endian to big endian)
            bytes memory originalNonceBytes = abi.encodePacked(originalNonce);

            // Last 4 bytes of the nonce are actually stored at the beginning in little endian
            bytes32 salt = bytes32(
                abi.encodePacked(
                    DEPLOYER, // First 20 bytes
                    hex"00", // 21st byte
                    originalNonceBytes[7], // Last 4 bytes in reverse order (little endian)
                    originalNonceBytes[6],
                    originalNonceBytes[5],
                    originalNonceBytes[4],
                    originalNonceBytes[3], // First 4 bytes in reverse order
                    originalNonceBytes[2],
                    originalNonceBytes[1],
                    originalNonceBytes[0],
                    bytes3(0x000000) // Padding
                )
            );

            // Process with _efficientHash
            bytes32 processedSalt = efficientHash(bytes32(uint256(uint160(DEPLOYER))), salt);
            address addr = createX.computeCreate3Address(processedSalt);
            console.log("  Processed with reversed nonce:", addr, addr == expectedAddress ? " [MATCH]" : "");
        }
    }

    function test_OriginalNonces_Method3() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        console.log("Testing with original nonces - Method 3...");

        // The original nonces from output.txt and their corresponding expected addresses
        bytes8[] memory originalNonces = new bytes8[](4);
        originalNonces[0] = hex"000000000176ce3f"; // First salt
        originalNonces[1] = hex"000000000207e4bb"; // Second salt
        originalNonces[2] = hex"00000000021199e1"; // Third salt
        originalNonces[3] = hex"00000000033f7856"; // Fourth salt

        address[] memory expectedAddresses = new address[](4);
        expectedAddresses[0] = 0xbbbBDEF37e6ebEB7f6Eec464dEE9A33955919300;
        expectedAddresses[1] = 0xBbBb5fc751BDd39553036922706Cc9eD9F32b100;
        expectedAddresses[2] = 0xbbBB7dc22F1006364fD291C9522d276B9f1d5F00;
        expectedAddresses[3] = 0xBBbb6AB200Fa31AdCA4Df6aba3ccA1Ada1Ff4100;

        for (uint256 i = 0; i < originalNonces.length; i++) {
            bytes8 originalNonce = originalNonces[i];
            address expectedAddress = expectedAddresses[i];

            console.log("Salt", i, "original nonce:", vm.toString(originalNonce));

            // Method 3: Try with nonce as a little-endian number in the last 11 bytes
            uint64 nonceValue = uint64(originalNonce);

            // Convert the nonce to a little-endian format (reverse byte order)
            uint64 reversedNonce = 0;
            for (uint256 j = 0; j < 8; j++) {
                reversedNonce = (reversedNonce << 8) | ((nonceValue >> (j * 8)) & 0xFF);
            }

            // Use the reversed nonce in the last 11 bytes of the salt
            bytes32 salt = bytes32(
                abi.encodePacked(
                    DEPLOYER, // First 20 bytes
                    hex"00", // 21st byte
                    bytes8(reversedNonce), // Reversed 8-byte nonce
                    bytes3(0x000000) // Padding
                )
            );

            // Process with _efficientHash
            bytes32 processedSalt = efficientHash(bytes32(uint256(uint160(DEPLOYER))), salt);
            address addr = createX.computeCreate3Address(processedSalt);
            console.log("  Processed with little-endian nonce:", addr, addr == expectedAddress ? " [MATCH]" : "");
        }
    }

    function test_OriginalNonces_CrunchLogic() public {
        // Use the specific deployer and factory that generated the output
        vm.startPrank(TEST_DEPLOYER);

        console.log("Testing with latest nonce from output.txt using createXcrunch logic...");

        // Use the latest nonce from output.txt
        // uint256 originalNonceValue = 16008469; // Updated Nonce
        uint256 originalNonceValue = 411295; // Nonce found by GPU cruncher

        // Use the corresponding expected address from output.txt
        // address expectedAddress = 0xBbBb6363e87132a8b1BD175CC739EA7705C5B000; // Updated Address
        address expectedAddress = 0xbBBbbb79330bbF22C6824B0116Aa83F65c7320F5; // CHECKSUMMED Address found by GPU cruncher

        console.log("\nTesting Nonce:", originalNonceValue);
        console.log("  Expected address:", expectedAddress);

        // Construct the 32-byte salt as createXcrunch does for the Sender variant:
        // Using TEST_DEPLOYER
        bytes memory initialSaltBytes = new bytes(32);
        bytes32 nonceBytes32 = bytes32(originalNonceValue);
        // Copy TEST_DEPLOYER address - CORRECTED
        for (uint256 j = 0; j < 20; j++) {
            initialSaltBytes[j] = bytes1(uint8(uint160(TEST_DEPLOYER) >> (152 - j * 8))); // Use TEST_DEPLOYER
        }
        initialSaltBytes[20] = hex"00"; // Flag byte
        // Copy last 11 bytes of nonce (bytes 21 to 31 of nonceBytes32)
        for (uint256 j = 0; j < 11; j++) {
            initialSaltBytes[21 + j] = nonceBytes32[21 + j];
        }
        bytes32 fullSalt = bytes32(initialSaltBytes);
        console.log("  Constructed Full Salt:", vm.toString(fullSalt));

        // Process this full salt using the efficientHash logic (mimicking CreateX internal step)
        // Using TEST_DEPLOYER - CORRECTED
        bytes32 processedSalt = efficientHash(
            bytes32(uint256(uint160(TEST_DEPLOYER))), // Use TEST_DEPLOYER
            fullSalt
        );
        console.log("  Processed Salt (after efficientHash):", vm.toString(processedSalt));

        // Compute the final address using the *processed* salt and TEST_FACTORY
        // createX is already set to TEST_FACTORY in setUp
        address computedAddress = createX.computeCreate3Address(processedSalt);
        console.log("  Computed Address (using processed salt):", computedAddress);

        // Verify the match against the *correct* expected address
        assertEq(computedAddress, expectedAddress, "Computed address does not match expected address from output.txt");
        console.log("  MATCH FOUND!");

        // Stop pranking
        vm.stopPrank();
    }

    function test_OriginalNonces_CrunchLogic_Direct() public {
        // Start pranking as the deployer
        vm.startPrank(DEPLOYER);

        console.log("Testing with original nonces using createXcrunch logic (Direct Salt)...");

        // The original nonces from output.txt and their corresponding expected addresses
        bytes8[] memory originalNonces = new bytes8[](4);
        originalNonces[0] = hex"000000000176ce3f"; // First salt
        originalNonces[1] = hex"000000000207e4bb"; // Second salt
        originalNonces[2] = hex"00000000021199e1"; // Third salt
        originalNonces[3] = hex"00000000033f7856"; // Fourth salt

        address[] memory expectedAddresses = new address[](4);
        expectedAddresses[0] = 0xBbBb6363e87132a8b1BD175CC739EA7705C5B000; // Checksummed
        expectedAddresses[1] = 0xBbbb1aDDf9A180a0981249716cdadC358C2C6d00; // Checksummed
        expectedAddresses[2] = 0xBbbbF6920cA6Ab2F7c6555D4FCC534f424352A00; // Checksummed
        expectedAddresses[3] = 0xBbBbdca1a7709788e61f427219e114922BB66600; // Checksummed

        for (uint256 i = 0; i < originalNonces.length; i++) {
            bytes8 originalNonce = originalNonces[i];
            address expectedAddress = expectedAddresses[i];

            console.log("\nSalt", i, "original nonce:", vm.toString(originalNonce));
            console.log("  Expected address:", expectedAddress);

            // Construct the 32-byte salt as createXcrunch does for the Sender variant:
            bytes32 fullSalt = bytes32(abi.encodePacked(DEPLOYER, hex"00", originalNonce, bytes3(0x000000)));
            console.log("  Constructed Full Salt:", vm.toString(fullSalt));

            // --- Hypothesis Test ---
            // Compute the final address using the *full* (unprocessed) salt directly.
            // Assume computeCreate3Address performs internal processing.
            address computedAddress = createX.computeCreate3Address(fullSalt);
            console.log("  Computed Address (using full salt directly):", computedAddress);

            // Verify the match
            assertEq(computedAddress, expectedAddress, "Computed address does not match expected address");
            console.log("  MATCH FOUND!");
        }

        // Stop pranking
        vm.stopPrank();
    }

    // Helper function to efficiently compute keccak256 hash of two bytes32 values
    // This is similar to how CreateX's _efficientHash works
    function efficientHash(bytes32 a, bytes32 b) internal pure returns (bytes32 hash) {
        assembly {
            mstore(0x00, a)
            mstore(0x20, b)
            hash := keccak256(0x00, 0x40)
        }
    }
}
